(window.webpackJsonp=window.webpackJsonp||[]).push([[692],{1040:function(t,s,e){"use strict";e.r(s);var a=e(19),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"preprocessor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#preprocessor"}},[t._v("#")]),t._v(" Preprocessor")]),t._v(" "),e("p",[t._v("The C preprocessor is a simple text parser/replacer that is run before the actual compilation of the code. Used to extend and ease the use of the C (and later C++) language, it can be used for:")]),t._v(" "),e("p",[t._v("a. "),e("strong",[t._v("Including other files")]),t._v(" using "),e("code",[t._v("#include")])]),t._v(" "),e("p",[t._v("b. "),e("strong",[t._v("Define a text-replacement macro")]),t._v(" using "),e("code",[t._v("#define")])]),t._v(" "),e("p",[t._v("c. "),e("strong",[t._v("Conditional Compilation")]),t._v(" using"),e("code",[t._v("#if")]),t._v(" "),e("code",[t._v("#ifdef")])]),t._v(" "),e("p",[t._v("d. "),e("strong",[t._v("Platform/Compiler specific logic")]),t._v(" (as an extension of conditional compilation)")]),t._v(" "),e("h2",{attrs:{id:"include-guards"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#include-guards"}},[t._v("#")]),t._v(" Include Guards")]),t._v(" "),e("p",[t._v("A header file may be included by other header files.   A source file (compilation unit) that includes multiple headers may therefore, indirectly, include some headers more than once.   If such a header file that is included more than once contains definitions, the compiler (after preprocessing) detects a violation of the One Definition Rule (e.g. ยง3.2 of the 2003 C++ standard) and therefore issues a diagnostic and compilation fails.")]),t._v(" "),e("p",[t._v('Multiple inclusion is prevented using "include guards", which are sometimes also known as header guards or macro guards.    These are implemented using the preprocessor '),e("code",[t._v("#define")]),t._v(", "),e("code",[t._v("#ifndef")]),t._v(", "),e("code",[t._v("#endif")]),t._v(" directives.")]),t._v(" "),e("p",[t._v("e.g.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Foo.h")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" FOO_H_INCLUDED ")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" FOO_H_INCLUDED")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  a class definition")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("The key advantage of using include guards is that they will work with all standard-compliant compilers and preprocessors.")]),t._v(" "),e("p",[t._v("However, include guards also cause some problems for developers, as it is necessary to ensure the macros are unique within all headers used in a project.  Specifically, if two (or more) headers use "),e("code",[t._v("FOO_H_INCLUDED")]),t._v(" as their include guard, the first of those headers included in a compilation unit will effectively prevent the others from being included.    Particular challenges are introduced if a project uses a number of third-party libraries with header files that happen to use include guards in common.")]),t._v(" "),e("p",[t._v("It is also necessary to ensure that the macros used in include guards do not conflict with any other macros defined in header files.")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Pragma_once#Portability",target:"_blank",rel:"noopener noreferrer"}},[t._v("Most C++ implementations"),e("OutboundLink")],1),t._v(" also support the "),e("code",[t._v("#pragma once")]),t._v(" directive which ensures the file is only included once within a single compilation. This is a "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/De_facto_standard",target:"_blank",rel:"noopener noreferrer"}},[e("strong",[t._v("de facto")]),t._v(" standard"),e("OutboundLink")],1),t._v(" directive, but it is not part of any ISO C++ standard. For example:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Foo.h")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("pragma")]),t._v(" once")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("While "),e("code",[t._v("#pragma once")]),t._v(" avoids some problems associated with include guards, a "),e("code",[t._v("#pragma")]),t._v(" - by definition in the standards - is inherently a compiler-specific hook, and will be silently ignored by compilers that don't support it.   Projects which use "),e("code",[t._v("#pragma once")]),t._v(" are more difficult to port to compilers that don't support it.")]),t._v(" "),e("p",[t._v("A number of coding guidelines and assurance standards for C++ specifically discourage any use of the preprocessor other than to "),e("code",[t._v("#include")]),t._v(" header files or for the purposes of placing include guards in headers.")]),t._v(" "),e("h2",{attrs:{id:"conditional-logic-and-cross-platform-handling"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conditional-logic-and-cross-platform-handling"}},[t._v("#")]),t._v(" Conditional logic and cross-platform handling")]),t._v(" "),e("p",[t._v("In a nutshell, conditional pre-processing logic is about making code-logic available or unavailable for compilation using macro definitions.")]),t._v(" "),e("p",[t._v("Three prominent use-cases are:")]),t._v(" "),e("ul",[e("li",[t._v("different "),e("strong",[t._v("app profiles")]),t._v(" (e.g. debug, release, testing, optimised) that can be candidates of the same app (e.g. with extra logging).")]),t._v(" "),e("li",[e("strong",[t._v("cross-platform compiles")]),t._v(" - single code-base, multiple compilation platforms.")]),t._v(" "),e("li",[t._v("utilising a common code-base for multiple "),e("strong",[t._v("application versions")]),t._v(" (e.g. Basic, Premium and Pro versions of a software) - with slightly different features.")])]),t._v(" "),e("p",[e("strong",[t._v("Example a:")]),t._v(" A cross-platform approach for removing files (illustrative):")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" _WIN32")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<windows.h>")]),t._v(" ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// and other windows system files")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<cstdio>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove_file")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("string "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("path"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" _WIN32")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("DeleteFile")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("c_str")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("elif")]),t._v(" defined(_POSIX_VERSION) || defined(__unix__)")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("c_str")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("elif")]),t._v(" defined(__APPLE__)")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//TODO: check if NSAPI has a more specific function with permission dialog")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("c_str")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")]),t._v(" ")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("error")]),t._v(' "This platform is not supported"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("Macros like "),e("code",[t._v("_WIN32")]),t._v(", "),e("code",[t._v("__APPLE__")]),t._v(" or "),e("code",[t._v("__unix__")]),t._v(" are normally predefined by corresponding implementations.")]),t._v(" "),e("p",[e("strong",[t._v("Example b:")]),t._v(" Enabling additional logging for a debug build:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("s_PrintAppStateOnUserPrompt")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"--------BEGIN-DUMP---------------\\n"')]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" AppState"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Instance")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Settings")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("ToString")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\n"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" ( 1 == TESTING_MODE ) ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//privacy: we want user details only when testing")]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("ListToString")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("AppState"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("UndoStack")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetActionNames")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" AppState"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Instance")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("CrntDocument")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Name")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" AppState"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Instance")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("CrntDocument")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SignatureSHA")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\n"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"--------END-DUMP---------------\\n"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("Example c:")]),t._v(" Enable a premium feature in a separate product build (note: this is illustrative. it is often a better idea to allow a feature to be unlocked without the need to reinstall an application)")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" MainWindow"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("OnProcessButtonClick")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" _PREMIUM")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("CreatePurchaseDialog")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Buy App Premium"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This feature is available for our App Premium users. Click the Buy button to purchase the Premium version at our website"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//...actual feature logic here")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("Some common tricks:")])]),t._v(" "),e("p",[e("strong",[t._v("Defining symbols at invocation time:")])]),t._v(" "),e("p",[t._v("The preprocessor can be called with predefined symbols (with optional initialisation). For example this command ("),e("code",[t._v("gcc -E")]),t._v(" runs only the preprocessor)")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[t._v("gcc "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("E "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("DOPTIMISE_FOR_OS_X "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("DTESTING_MODE"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" Sample"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cpp\n\n")])])]),e("p",[t._v("processes Sample.cpp in the same way as it would if "),e("code",[t._v("#define OPTIMISE_FOR_OS_X")]),t._v(" and "),e("code",[t._v("#define TESTING_MODE 1")]),t._v(" were added to the top of Sample.cpp.")]),t._v(" "),e("p",[e("strong",[t._v("Ensuring a macro is defined:")])]),t._v(" "),e("p",[t._v("If a macro isn't defined and its value is compared or checked, the preprocessor almost always silently assumes the value to be "),e("code",[t._v("0")]),t._v(". There are a few ways to work with this. One approach is to assume that the default settings are represented as 0, and any changes (e.g. to the app build profile) needs to be explicitly done (e.g. ENABLE_EXTRA_DEBUGGING=0 by default, set -DENABLE_EXTRA_DEBUGGING=1 to override). Another approach is make all definitions and defaults explicit. This can be achieved using a combination of "),e("code",[t._v("#ifndef")]),t._v(" and "),e("code",[t._v("#error")]),t._v(" directives:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" (ENABLE_EXTRA_DEBUGGING)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// please include DefaultDefines.h if not already included.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#    "),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("error")]),t._v(' "ENABLE_EXTRA_DEBUGGING is not defined"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#    "),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" ( 1 == ENABLE_EXTRA_DEBUGGING )")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//code")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#    "),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("h2",{attrs:{id:"macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#macros"}},[t._v("#")]),t._v(" Macros")]),t._v(" "),e("p",[t._v("Macros are categorized into two main groups: object-like macros and function-like macros. Macros are treated as a token substitution early in the compilation process. This means that large (or repeating) sections of code can be abstracted into a preprocessor macro.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This is an object-like macro")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v("    PI         3.14159265358979")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This is a function-like macro.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Note that we can use previously defined macros")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// in other macro definitions (object-like or function-like)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// But watch out, its quite useful if you know what you're doing, but the")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler doesnt know which type to handle, so using inline functions instead")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// is quite recommended (But e.g. for Minimum/Maximum functions it is quite useful)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v("    AREA(r)    (PI*(r)*(r))")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// They can be used like this:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" pi_macro   "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" PI"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" area_macro "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("AREA")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("The Qt library makes use of this technique to create a meta-object system by having the user declare the Q_OBJECT macro at the head of the user-defined class extending QObject.")]),t._v(" "),e("p",[t._v("Macro names are usually written in all caps, to make them easier to differentiate from normal code.  This isn't a requirement, but is merely considered good style by many programmers.")]),t._v(" "),e("p",[t._v("When an object-like macro is encountered, it's expanded as a simple copy-paste operation, with the macro's name being replaced with its definition.  When a function-like macro is encountered, both its name and its parameters are expanded.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" pi_squared "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" PI "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" PI"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" pi_squared "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.14159265358979")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.14159265358979")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" area "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("AREA")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" area "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.14159265358979")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),e("p",[t._v("Due to this, function-like macro parameters are often enclosed within parentheses, as in "),e("code",[t._v("AREA()")]),t._v(" above.  This is to prevent any bugs that can occur during macro expansion, specifically bugs caused by a single macro parameter being composed of multiple actual values.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" BAD_AREA(r) PI * r * r")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" bad_area "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("BAD_AREA")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" bad_area "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.14159265358979")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.6")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" good_area "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("AREA")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" good_area "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.14159265358979")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Also note that due to this simple expansion, care must be taken with the parameters passed to macros, to prevent unexpected side effects.  If the parameter is modified during evaluation, it will be modified each time it is used in the expanded macro, which usually isn't what we want.  This is true even if the macro encloses the parameters in parentheses to prevent expansion from breaking anything.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" oops "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" incremental_damage "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("AREA")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oops"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" incremental_damage "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.14159265358979")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oops"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oops"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Additionally, macros provide no type-safety, leading to hard-to-understand errors about type mismatch.")]),t._v(" "),e("p",[t._v('As programmers normally terminate lines with a semicolon, macros that are intended to be used as standalone lines are often designed to "swallow" a semicolon; this prevents any unintended bugs from being caused by an extra semicolon.')]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" IF_BREAKER(Func) Func();")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_condition"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Oops.")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("IF_BREAKER")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_func"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n    std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"I am accidentally an orphan."')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("endl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("In this example, the inadvertent double semicolon breaks the "),e("code",[t._v("if...else")]),t._v(" block, preventing the compiler from matching the "),e("code",[t._v("else")]),t._v(" to the "),e("code",[t._v("if")]),t._v('.  To prevent this, the semicolon is omitted from the macro definition, which will cause it to "swallow" the semicolon immediately following any usage of it.')]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" IF_FIXER(Func) Func()")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_condition"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("IF_FIXER")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_func"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n    std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hooray!  I work again!"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("endl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Leaving off the trailing semicolon also allows the macro to be used without ending the current statement, which can be beneficial.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DO_SOMETHING(Func, Param) Func(Param, 2)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("some_function")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("DO_SOMETHING")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_func"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("DO_SOMETHING")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_func"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Normally, a macro definition ends at the end of the line.  If a macro needs to cover multiple lines, however, a backslash can be used at the end of a line to indicate this.  This backslash must be the last character in the line, which indicates to the preprocessor that the following line should be concatenated onto the current line, treating them as a single line.  This can be used multiple times in a row.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' TEXT "I \\\nam \\\nmany \\\nlines."')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n\nstd"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" TEXT "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("endl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Output:   I am many lines.")]),t._v("\n\n")])])]),e("p",[t._v("This is especially useful in complex function-like macros, which may need to cover multiple lines.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" CREATE_OUTPUT_AND_DELETE(Str) \\\n    std::string* tmp = new std::string(Str); \\\n    std::cout << *tmp << std::endl; \\\n    delete tmp;")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("CREATE_OUTPUT_AND_DELETE")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"There's no real need for this to use 'new'.\"")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),e("p",[t._v("In the case of more complex function-like macros, it can be useful to give them their own scope to prevent possible name collisions or to cause objects to be destroyed at the end of the macro, similar to an actual function.  A common idiom for this is "),e("strong",[t._v("do while 0")]),t._v(", where the macro is enclosed in a "),e("strong",[t._v("do-while")]),t._v(" block.  This block is generally "),e("strong",[t._v("not")]),t._v(" followed with a semicolon, allowing it to swallow a semicolon.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DO_STUFF(Type, Param, ReturnVar) do { \\\n    Type temp(some_setup_values); \\\n    ReturnVar = temp.process(Param); \\\n} while (0)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("DO_STUFF")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyClass"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("41153.7")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    MyClass "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("temp")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_setup_values"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    x "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" temp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("process")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("41153.7")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v('There are also variadic macros; similarly to variadic functions, these take a variable number of arguments, and then expand them all in place of a special "Varargs" parameter, '),e("code",[t._v("__VA_ARGS__")]),t._v(".")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" VARIADIC(Param, ...) Param(__VA_ARGS__)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("VARIADIC")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("printf"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Note that during expansion, "),e("code",[t._v("__VA_ARGS__")]),t._v(" can be placed anywhere in the definition, and will be expanded correctly.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" VARIADIC2(POne, PTwo, PThree, ...) POne(PThree, __VA_ARGS__, PTwo)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("VARIADIC2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("some_func"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("some_func")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("In the case of a zero-argument variadic parameter, different compilers will handle the trailing comma differently.  Some compilers, such as Visual Studio, will silently swallow the comma without any special syntax.  Other compilers, such as GCC, require you to place "),e("code",[t._v("##")]),t._v(" immediately before "),e("code",[t._v("__VA_ARGS__")]),t._v(".  Due to this, it is wise to conditionally define variadic macros when portability is a concern.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// In this example, COMPILER is a user-defined macro specifying the compiler being used.")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v('       COMPILER == "VS"')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" VARIADIC3(Name, Param, ...) Name(Param, __VA_ARGS__)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("elif")]),t._v('     COMPILER == "GCC"')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" VARIADIC3(Name, Param, ...) Name(Param, ##__VA_ARGS__)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")]),t._v(" ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* COMPILER */")]),t._v("\n\n")])])]),e("h2",{attrs:{id:"x-macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#x-macros"}},[t._v("#")]),t._v(" X-macros")]),t._v(" "),e("p",[t._v("An idiomatic technique for generating repeating code structures at compile time.")]),t._v(" "),e("p",[t._v("An X-macro consists of two parts: the list, and the execution of the list.")]),t._v(" "),e("p",[t._v("Example:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" LIST \\\n    X(dog)   \\\n    X(cat)   \\\n    X(racoon)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// class Animal {")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  public:")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//    void say();")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// };")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" X(name) Animal name;")]),t._v("\nLIST\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("undef")]),t._v(" X")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" X(name) name.say();")]),t._v("\n    LIST\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("undef")]),t._v(" X")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("which is expanded by the preprocessor into the following:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[t._v("Animal dog"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nAnimal cat"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nAnimal racoon"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    dog"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cat"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    racoon"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("say")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("    \n\n")])])]),e("p",[t._v("As lists become bigger (let's say, more than 100 elements), this technique helps to avoid excessive copy-pasting.")]),t._v(" "),e("p",[t._v("Source: "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/X_Macro",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://en.wikipedia.org/wiki/X_Macro"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("See also: "),e("a",{attrs:{href:"http://stackoverflow.com/documentation/c/628/x-macros",target:"_blank",rel:"noopener noreferrer"}},[t._v("X-macros"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("If defining a seamingly irrelevant "),e("code",[t._v("X")]),t._v(" before using "),e("code",[t._v("LIST")]),t._v(" is not to your liking, you can pass a macro name as an argument as well:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" LIST(MACRO) \\\n    MACRO(dog) \\\n    MACRO(cat) \\\n    MACRO(racoon)")]),t._v("\n\n")])])]),e("p",[t._v("Now, you explicitly specify which macro should be used when expanding the list, e.g.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" FORWARD_DECLARE_ANIMAL(name) Animal name;")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("LIST")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FORWARD_DECLARE_ANIMAL"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),e("p",[t._v("If each invocation of the "),e("code",[t._v("MACRO")]),t._v(" should take additional parameters - constant with respect to the list, variadic macros can be used")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//a walkaround for Visual studio")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" EXPAND(x) x")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" LIST(MACRO, ...) \\\n    EXPAND(MACRO(dog, __VA_ARGS__)) \\\n    EXPAND(MACRO(cat, __VA_ARGS__)) \\\n    EXPAND(MACRO(racoon, __VA_ARGS__))")]),t._v("\n\n")])])]),e("p",[t._v("The first argument is supplied by the "),e("code",[t._v("LIST")]),t._v(", while the rest is provided by the user in the "),e("code",[t._v("LIST")]),t._v(" invocation. For example:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" FORWARD_DECLARE(name, type, prefix) type prefix##name;")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("LIST")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FORWARD_DECLARE"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("Animal"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("anim_"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("LIST")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FORWARD_DECLARE"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("Object"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("obj_"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),e("p",[t._v("will expand to")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[t._v("Animal anim_dog"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nAnimal anim_cat"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nAnimal anim_racoon"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nObject obj_dog"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nObject obj_cat"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nObject obj_racoon"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        \n\n")])])]),e("h2",{attrs:{id:"preprocessor-error-messages"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#preprocessor-error-messages"}},[t._v("#")]),t._v(" Preprocessor error messages")]),t._v(" "),e("p",[t._v("Compile errors can be generated using the preprocessor. This is useful for a number of reasons some of which include, notifying a user if they are on an unsupported platform or an unsupported compiler.")]),t._v(" "),e("p",[t._v("e.g. Return Error if gcc version is 3.0.0 or earlier.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" __GNUC__ < 3")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("error")]),t._v(' "This code requires gcc > 3.0.0"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("e.g. Return Error if compiling on an Apple computer.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __APPLE__")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("error")]),t._v(' "Apple products are not supported in this release"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("h2",{attrs:{id:"predefined-macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#predefined-macros"}},[t._v("#")]),t._v(" Predefined macros")]),t._v(" "),e("p",[t._v("Predefined macros are those that the compiler defines (in contrast to those user defines in the source file). Those macros must not be re-defined or undefined by user.")]),t._v(" "),e("p",[t._v("The following macros are predefined by the C++ standard:")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("__LINE__")]),t._v(" contains the line number of the line this macro is used on, and can be changed by the "),e("code",[t._v("#line")]),t._v(" directive.")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__FILE__")]),t._v(" contains the filename of the file this macro is used in, and can be changed by the "),e("code",[t._v("#line")]),t._v(" directive.")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__DATE__")]),t._v(" contains date (in "),e("code",[t._v('"Mmm dd yyyy"')]),t._v(" format) of the file compilation, where "),e("strong",[t._v("Mmm")]),t._v(" is formatted as if obtained by a call to "),e("code",[t._v("std::asctime()")]),t._v(".")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__TIME__")]),t._v(" contains time (in "),e("code",[t._v('"hh:mm:ss"')]),t._v(" format) of the file compilation.")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__cplusplus")]),t._v(" is defined by (conformant) C++ compilers while compiling C++ files. Its value is the standard version the compiler is "),e("strong",[t._v("fully")]),t._v(" conformant with, i.e. "),e("code",[t._v("199711L")]),t._v(" for C++98 and C++03, "),e("code",[t._v("201103L")]),t._v(" for C++11 and "),e("code",[t._v("201402L")]),t._v(" for C++14 standard.")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDC_HOSTED__")]),t._v(" is defined to "),e("code",[t._v("1")]),t._v(" if the implementation is "),e("strong",[t._v("hosted")]),t._v(", or "),e("code",[t._v("0")]),t._v(" if it is "),e("strong",[t._v("freestanding")]),t._v(".")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDCPP_DEFAULT_NEW_ALIGNMENT__")]),t._v(" contains a "),e("code",[t._v("size_t")]),t._v(" literal, which is the alignment used for a call to alignment-unaware "),e("code",[t._v("operator new")]),t._v(".")])])]),t._v(" "),e("p",[t._v("Additionally, the following macros are allowed to be predefined by implementations, and may or may not be present:")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("__STDC__")]),t._v(" has implementation-dependent meaning, and is usually defined only when compiling a file as C, to signify full C standard compliance.  (Or never, if the compiler decides not to support this macro.)")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDC_VERSION__")]),t._v(" has implementation-dependent meaning, and its value is usually the C version, similarly to how "),e("code",[t._v("__cplusplus")]),t._v(" is the C++ version.  (Or is not even defined, if the compiler decides not to support this macro.)")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDC_MB_MIGHT_NEQ_WC__")]),t._v(" is defined to "),e("code",[t._v("1")]),t._v(", if values of the narrow encoding of the basic character set might not be equal to the values of their wide counterparts (e.g. if "),e("code",[t._v("(uintmax_t)'x' != (uintmax_t)L'x'")]),t._v(")")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDC_ISO_10646__")]),t._v(" is defined if "),e("code",[t._v("wchar_t")]),t._v(" is encoded as Unicode, and expands to an integer constant in the form "),e("code",[t._v("yyyymmL")]),t._v(", indicating the latest Unicode revision supported.")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDCPP_STRICT_POINTER_SAFETY__")]),t._v(" is defined to "),e("code",[t._v("1")]),t._v(", if the implementation has "),e("strong",[t._v("strict pointer safety")]),t._v(" (otherwise it has "),e("strong",[t._v("relaxed pointer safety")]),t._v(")")])]),t._v(" "),e("li",[e("p",[e("code",[t._v("__STDCPP_THREADS__")]),t._v(" is defined to "),e("code",[t._v("1")]),t._v(", if the program can have more than one thread of execution (applicable to "),e("strong",[t._v("freestanding implementation")]),t._v(" โ "),e("strong",[t._v("hosted implementations")]),t._v(" can always have more than one thread)")])])]),t._v(" "),e("p",[t._v("It is also worth mentioning "),e("code",[t._v("__func__")]),t._v(", which is not an macro, but a predefined function-local variable. It contains the name of the function it is used in, as a static character array in an implementation-defined format.")]),t._v(" "),e("p",[t._v("On top of those standard predefined macros, compilers can have their own set of predefined macros. One must refer to the compiler documentation to learn those. E.g.:")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("gcc"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://msdn.microsoft.com/en-us/library/b0084kay.aspx#Anchor_2",target:"_blank",rel:"noopener noreferrer"}},[t._v("Microsoft Visual C++"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://clang.llvm.org/docs/LanguageExtensions.html#builtin-macros",target:"_blank",rel:"noopener noreferrer"}},[t._v("clang"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://software.intel.com/en-us/node/514528",target:"_blank",rel:"noopener noreferrer"}},[t._v("Intel C++ Compiler"),e("OutboundLink")],1)])]),t._v(" "),e("p",[t._v("Some of the macros are just to query support of some feature:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __cplusplus ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// if compiled by C++ compiler")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// C code has to be decorated")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// C library header declarations here")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("Others are very useful for debugging:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v(" success "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("doSomething")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*some arguments*/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("success "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cerr "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ERROR: doSomething() failed on line "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__LINE__")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('" in function "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__func__")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"()"')]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('" in file "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__FILE__")]),t._v("\n              "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("endl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("And others for trivial version control:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("argv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" argc "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("string")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" argv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-v"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello World program\\n"')]),t._v("\n                  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"v 1.1\\n"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// I have to remember to update this manually")]),t._v("\n                  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"compiled: "')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__DATE__")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("' '")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__TIME__")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// this updates automagically")]),t._v("\n                  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("endl"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        std"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v("cout "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello World!\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("h2",{attrs:{id:"pragma-once"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pragma-once"}},[t._v("#")]),t._v(" #pragma once")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Pragma_once#Portability",target:"_blank",rel:"noopener noreferrer"}},[t._v("Most, but not all, C++ implementations"),e("OutboundLink")],1),t._v(" support the "),e("code",[t._v("#pragma once")]),t._v(" directive which ensures the file is only included once within a single compilation. It is not part of any ISO C++ standard. For example:")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Foo.h")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("pragma")]),t._v(" once")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("While "),e("code",[t._v("#pragma once")]),t._v(" avoids some problems associated with "),e("a",{attrs:{href:"http://stackoverflow.com/documentation/c%2b%2b/1098/preprocessor/3525/include-guards",target:"_blank",rel:"noopener noreferrer"}},[t._v("include guards"),e("OutboundLink")],1),t._v(", a "),e("code",[t._v("#pragma")]),t._v(" - by definition in the standards - is inherently a compiler-specific hook, and will be silently ignored by compilers that don't support it. Projects which use "),e("code",[t._v("#pragma once")]),t._v(" must be modified to be standard-compliant.")]),t._v(" "),e("p",[t._v("With some compilers - particularly those that employ "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Precompiled_header",target:"_blank",rel:"noopener noreferrer"}},[t._v("precompiled headers"),e("OutboundLink")],1),t._v(" - "),e("code",[t._v("#pragma once")]),t._v(" can result in a considerable speedup of the compilation process.  Similarly, some preprocessors achieve speedup of compilation by tracking which headers have employed include guards.  The net benefit, when both "),e("code",[t._v("#pragma once")]),t._v(" and include guards are employed, depends on the implementation and can be either an increase or decrease of compilation times.")]),t._v(" "),e("p",[e("code",[t._v("#pragma once")]),t._v(" combined with "),e("a",{attrs:{href:"http://stackoverflow.com/documentation/c%2b%2b/1098/preprocessor/3525/include-guards",target:"_blank",rel:"noopener noreferrer"}},[t._v("include guards"),e("OutboundLink")],1),t._v(" was the recommended layout for header files when writing MFC based applications on windows, and was generated by Visual Studioโs "),e("code",[t._v("add class")]),t._v(", "),e("code",[t._v("add dialog")]),t._v(", "),e("code",[t._v("add windows")]),t._v(" wizards.   Hence it is very common to find them combined in C++ Windows Applicants.")]),t._v(" "),e("h2",{attrs:{id:"preprocessor-operators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#preprocessor-operators"}},[t._v("#")]),t._v(" Preprocessor Operators")]),t._v(" "),e("p",[e("code",[t._v("#")]),t._v(" operator or stringizing operator is used to convert a Macro parameter to a string literal. It can only be used with the Macros having arguments.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// preprocessor will convert the parameter x to the string literal x")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' PRINT(x) printf(#x "\\n")')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("PRINT")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("This line will be converted to string by preprocessor"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This line will be converted to string by preprocessor"')]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Compiler concatenate two strings and the final "),e("code",[t._v("printf()")]),t._v(" argument will be a string literal with newline character at its end.")]),t._v(" "),e("p",[t._v("Preprocessor will ignore the spaces before or after the macro argument. So below print statement will give us the same result.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("PRINT")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("   This line will be converted to string by preprocessor "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("If the parameter of the string literal requires an escape sequence like before a double quote() it will automatically be inserted by the preprocessor.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("PRINT")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("This "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"line"')]),t._v(" will be converted to "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),t._v(" by preprocessor"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Compiler sees")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This \\"line\\" will be converted to \\"string\\" by preprocessor"')]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[e("code",[t._v("##")]),t._v(" operator or Token pasting operator is used to concatenate two parameters or tokens of a Macro.")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// preprocessor will combine the variable and the x")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' PRINT(x) printf("variable" #x " = %d", variable##x)')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" variableY "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("PRINT")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Y"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//compiler sees")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"variable"')]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Y"')]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('" = %d"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" variableY"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("and the final output will be")]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[t._v("variableY "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v("\n\n")])])]),e("h4",{attrs:{id:"remarks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),e("p",[t._v("Preprocessor statements are executed before your source files are handed to the compiler. They are capable of very low level conditional logic. Since preprocessor constructs (e.g. object-like macros) aren't typed like normal functions (the preprocessing step happens before compilation) the compiler cannot enforce type checks, they should therefore be carefully used.")])])}),[],!1,null,null,null);s.default=n.exports}}]);