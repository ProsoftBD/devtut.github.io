(window.webpackJsonp=window.webpackJsonp||[]).push([[669],{1013:function(t,a,n){"use strict";n.r(a);var s=n(19),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"linkage-specifications"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linkage-specifications"}},[t._v("#")]),t._v(" Linkage specifications")]),t._v(" "),n("p",[t._v("A linkage specification tells the compiler to compile declarations in a way that allows them to be linked together with declarations written in another language, such as C.")]),t._v(" "),n("h2",{attrs:{id:"signal-handler-for-unix-like-operating-system"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#signal-handler-for-unix-like-operating-system"}},[t._v("#")]),t._v(" Signal handler for Unix-like operating system")]),t._v(" "),n("p",[t._v("Since a signal handler will be called by the kernel using the C calling convention, we must tell the compiler to use the C calling convention when compiling the function.")]),t._v(" "),n("div",{staticClass:"language-cpp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-cpp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" sig_atomic_t death_signal "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("cleanup")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" signum"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    death_signal "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" signum"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("listen")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SIGTERM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" cleanup"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" fd "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("accept")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fd "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" errno "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" EINTR "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" death_signal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Caught signal %d; shutting down\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" death_signal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),n("h2",{attrs:{id:"making-a-c-library-header-compatible-with-c"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#making-a-c-library-header-compatible-with-c"}},[t._v("#")]),t._v(" Making a C library header compatible with C++")]),t._v(" "),n("p",[t._v("A C library header can usually be included into a C++ program, since most declarations are valid in both C and C++. For example, consider the following "),n("code",[t._v("foo.h")]),t._v(":")]),t._v(" "),n("div",{staticClass:"language-cpp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-cpp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" bar"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" Foo"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nFoo "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("make_foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),n("p",[t._v("The definition of "),n("code",[t._v("make_foo")]),t._v(" is separately compiled and distributed with the header in object form.")]),t._v(" "),n("p",[t._v("A C++ program can "),n("code",[t._v("#include <foo.h>")]),t._v(", but the compiler will not know that the "),n("code",[t._v("make_foo")]),t._v(" function is defined as a C symbol, and will probably try to look for it with a mangled name, and fail to locate it. Even if it can find the definition of "),n("code",[t._v("make_foo")]),t._v(" in the library, not all platforms use the same calling conventions for C and C++, and the C++ compiler will use the C++ calling convention when calling "),n("code",[t._v("make_foo")]),t._v(", which is likely to cause a segmentation fault if "),n("code",[t._v("make_foo")]),t._v(" is expecting to be called with the C calling convention.")]),t._v(" "),n("p",[t._v("The way to remedy this problem is to wrap almost all the declarations in the header in an "),n("code",[t._v('extern "C"')]),t._v(" block.")]),t._v(" "),n("div",{staticClass:"language-cpp extra-class"},[n("pre",{pre:!0,attrs:{class:"language-cpp"}},[n("code",[n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __cplusplus")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Foo")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" bar"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" Foo"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nFoo "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("make_foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __cplusplus")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/* end of "extern C" block */')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),n("p",[t._v("Now when "),n("code",[t._v("foo.h")]),t._v(" is included from a C program, it will just appear as ordinary declarations, but when "),n("code",[t._v("foo.h")]),t._v(" is included from a C++ program, "),n("code",[t._v("make_foo")]),t._v(" will be inside an "),n("code",[t._v('extern "C"')]),t._v(" block and the compiler will know to look for an unmangled name and use the C calling convention.")]),t._v(" "),n("h4",{attrs:{id:"syntax"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),n("ul",[n("li",[t._v("extern "),n("strong",[t._v("string-literal")]),t._v(" { "),n("strong",[t._v("declaration-seq")]),t._v("("),n("strong",[t._v("opt")]),t._v(") }")]),t._v(" "),n("li",[t._v("extern "),n("strong",[t._v("string-literal")]),t._v(" "),n("strong",[t._v("declaration")])])]),t._v(" "),n("h4",{attrs:{id:"remarks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),n("p",[t._v("The standard requires all compilers to support "),n("code",[t._v('extern "C"')]),t._v(" in order to allow C++ to be compatible with C, and "),n("code",[t._v('extern "C++"')]),t._v(", which may be used to override an enclosing linkage specification and restore the default. Other supported linkage specifications are "),n("a",{attrs:{href:"http://stackoverflow.com/documentation/c%2b%2b/1363/implementation-defined-behavior",target:"_blank",rel:"noopener noreferrer"}},[t._v("implementation-defined"),n("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);a.default=e.exports}}]);