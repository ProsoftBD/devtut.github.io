(window.webpackJsonp=window.webpackJsonp||[]).push([[581],{928:function(t,e,a){"use strict";a.r(e);var s=a(19),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"memory-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#memory-management"}},[t._v("#")]),t._v(" Memory management")]),t._v(" "),a("p",[t._v("For managing dynamically allocated memory, the standard C library provides the functions "),a("code",[t._v("malloc()")]),t._v(", "),a("code",[t._v("calloc()")]),t._v(", "),a("code",[t._v("realloc()")]),t._v(" and "),a("code",[t._v("free()")]),t._v(". In C99 and later, there is also "),a("code",[t._v("aligned_alloc()")]),t._v(".  Some systems also provide "),a("code",[t._v("alloca()")]),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"freeing-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#freeing-memory"}},[t._v("#")]),t._v(" Freeing Memory")]),t._v(" "),a("p",[t._v("It is possible to release dynamically allocated memory by calling "),a("a",{attrs:{href:"http://linux.die.net/man/3/free",target:"_blank",rel:"noopener noreferrer"}},[t._v("free()"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* allocation of memory */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"malloc failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* release of memory */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* note that after free(p), even using the *value* of the pointer p\n   has undefined behavior, until a new value is stored into it. */")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* reusing/re-purposing the pointer itself */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* This is valid, has defined behaviour */")]),t._v("\n\n")])])]),a("p",[t._v("The memory pointed to by "),a("code",[t._v("p")]),t._v(" is reclaimed (either by the libc implementation or by the underlying OS) after the call to "),a("code",[t._v("free()")]),t._v(", so accessing that freed memory block via "),a("code",[t._v("p")]),t._v(" will lead to "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/364/undefined-behavior#t=201607290847035891683",target:"_blank",rel:"noopener noreferrer"}},[t._v("undefined behavior"),a("OutboundLink")],1),t._v(". Pointers that reference memory elements that have been freed are commonly called "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Dangling_pointer",target:"_blank",rel:"noopener noreferrer"}},[t._v("dangling pointers"),a("OutboundLink")],1),t._v(", and present a security risk. Furthermore, the C standard states that even "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/364/undefined-behavior/2775/read-value-of-pointer-that-was-freed#t=201608050732042665317",target:"_blank",rel:"noopener noreferrer"}},[t._v("accessing the value"),a("OutboundLink")],1),t._v(" of a dangling pointer has undefined behavior. Note that the pointer "),a("code",[t._v("p")]),t._v(" itself can be re-purposed as shown above.")]),t._v(" "),a("p",[t._v("Please note that you can only call "),a("code",[t._v("free()")]),t._v(" on pointers that have directly been returned from the "),a("code",[t._v("malloc()")]),t._v(", "),a("code",[t._v("calloc()")]),t._v(", "),a("code",[t._v("realloc()")]),t._v(" and "),a("code",[t._v("aligned_alloc()")]),t._v(" functions, or where documentation tells you the memory has been allocated that way (functions like "),a("code",[t._v("strdup ()")]),t._v(" are notable examples). Freeing a pointer that is,")]),t._v(" "),a("ul",[a("li",[t._v("obtained by using the "),a("code",[t._v("&")]),t._v(" operator on a variable, or")]),t._v(" "),a("li",[t._v("in the middle of an allocated block,")])]),t._v(" "),a("p",[t._v("is forbidden. Such an error will usually not be diagnosed by your compiler but will lead the program execution in an undefined state.")]),t._v(" "),a("p",[t._v("There are two common strategies to prevent such instances of undefined behavior.")]),t._v(" "),a("p",[t._v("The first and preferable is simple - have "),a("code",[t._v("p")]),t._v(" itself cease to exist when it is no longer needed, for example:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("something_is_needed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"malloc failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* do whatever is needed with p */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("By calling "),a("code",[t._v("free()")]),t._v(" directly before the end of the containing block (i.e. the "),a("code",[t._v("}")]),t._v("), "),a("code",[t._v("p")]),t._v(" itself ceases to exist. The compiler will give a compilation error on any attempt to use "),a("code",[t._v("p")]),t._v(" after that.")]),t._v(" "),a("p",[t._v("A second approach is to also invalidate the pointer itself after releasing the memory to which it points:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// you may also use 0 instead of NULL")]),t._v("\n\n")])])]),a("p",[t._v("Arguments for this approach:")]),t._v(" "),a("li",[t._v("\nOn many platforms, an attempt to dereference a null pointer will cause instant crash: Segmentation fault. Here, we get at least a stack trace pointing to the variable that was used after being freed.\nWithout setting pointer to `NULL` we have dangling pointer. The program will very likely still crash, but later, because the memory to which the pointer points will silently be corrupted. Such bugs are difficult to trace because they can result in a call stack that completely unrelated to the initial problem.\nThis approach hence follows the [fail-fast concept](https://en.wikipedia.org/wiki/Fail-fast).\n")]),t._v(" "),a("li",[t._v("\nIt is safe to free a null pointer. The [C Standard specifies](http://port70.net/%7Ensz/c/c89/c89-draft.html#4.10.3.2) that `free(NULL)` has no effect:\n"),a("blockquote",[t._v("\nThe free function causes the space pointed to by ptr to be deallocated, that is, made available for further allocation. If ptr is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the `calloc`, `malloc`, or `realloc` function, or if the space has been deallocated by a call to `free` or `realloc`, the behavior is undefined.\n")])]),t._v(" "),a("ul",[a("li",[t._v("Sometimes the first approach cannot be used (e.g. memory is allocated in one function, and deallocated much later in a completely different function)")])]),t._v(" "),a("h2",{attrs:{id:"allocating-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allocating-memory"}},[t._v("#")]),t._v(" Allocating Memory")]),t._v(" "),a("h3",{attrs:{id:"standard-allocation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#standard-allocation"}},[t._v("#")]),t._v(" Standard Allocation")]),t._v(" "),a("p",[t._v("The C dynamic memory allocation functions are defined in the "),a("code",[t._v("<stdlib.h>")]),t._v(" header. If one wishes to allocate memory space for an object dynamically, the following code can be used:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"malloc() failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("This computes the number of bytes that ten "),a("code",[t._v("int")]),t._v("s occupy in memory, then requests that many bytes from "),a("code",[t._v("malloc")]),t._v(" and assigns the result (i.e., the starting address of the memory chunk that was just created using "),a("code",[t._v("malloc")]),t._v(")  to a pointer named "),a("code",[t._v("p")]),t._v(".")]),t._v(" "),a("p",[t._v("It is good practice to use "),a("code",[t._v("sizeof")]),t._v(" to compute the amount of memory to request since the result of "),a("code",[t._v("sizeof")]),t._v(" is implementation defined (except for "),a("strong",[t._v("character types")]),t._v(", which are "),a("code",[t._v("char")]),t._v(", "),a("code",[t._v("signed char")]),t._v(" and "),a("code",[t._v("unsigned char")]),t._v(", for which "),a("code",[t._v("sizeof")]),t._v(" is defined to always give "),a("code",[t._v("1")]),t._v(").")]),t._v(" "),a("p",[a("strong",[t._v("Because "),a("code",[t._v("malloc")]),t._v(" might not be able to service the request, it might return a null pointer. It is important to check for this to prevent later attempts to dereference the null pointer.")])]),t._v(" "),a("p",[t._v("Memory dynamically allocated using "),a("code",[t._v("malloc()")]),t._v(" may be resized using "),a("code",[t._v("realloc()")]),t._v(" or, when no longer needed, released using "),a("code",[t._v("free()")]),t._v(".")]),t._v(" "),a("p",[t._v("Alternatively, declaring "),a("code",[t._v("int array[10];")]),t._v(" would allocate the same amount of memory.  However, if it is declared inside a function without the keyword "),a("code",[t._v("static")]),t._v(", it will only be usable within the function it is declared in and the functions it calls (because the array will be allocated on the stack and the space will be released for reuse when the function returns). Alternatively, if it is defined with "),a("code",[t._v("static")]),t._v(" inside a function, or if it is defined outside any function, then its lifetime is the lifetime of the program. Pointers can also be returned from a function, however a function in C can not return an array.")]),t._v(" "),a("h3",{attrs:{id:"zeroed-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zeroed-memory"}},[t._v("#")]),t._v(" Zeroed Memory")]),t._v(" "),a("p",[t._v("The memory returned by "),a("code",[t._v("malloc")]),t._v(" may not be initialized to a reasonable value, and care should be taken to zero the memory with "),a("code",[t._v("memset")]),t._v(" or to immediately copy a suitable value into it. Alternatively, "),a("code",[t._v("calloc")]),t._v(" returns a block of the desired size where all bits are initialized to "),a("code",[t._v("0")]),t._v(". This need not be the same as the representation of floating-point zero or a null pointer constant.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("calloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"calloc() failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[a("sub",[a("strong",[t._v("A note on "),a("code",[t._v("calloc")]),t._v(":")]),t._v(" Most (commonly used) implementations will optimise "),a("code",[t._v("calloc()")]),t._v(" for performance, so it will be "),a("a",{attrs:{href:"http://stackoverflow.com/a/2688522/130580",target:"_blank",rel:"noopener noreferrer"}},[t._v("faster"),a("OutboundLink")],1),t._v(" than calling "),a("code",[t._v("malloc()")]),t._v(", then "),a("code",[t._v("memset()")]),t._v(", even though the net effect is identical.")])]),t._v(" "),a("h3",{attrs:{id:"aligned-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aligned-memory"}},[t._v("#")]),t._v(" Aligned Memory")]),t._v(" "),a("p",[t._v("C11 introduced a new function "),a("code",[t._v("aligned_alloc()")]),t._v(" which allocates space with the given alignment. It can be used if the memory to be allocated is needed to be aligned at certain boundaries which can't be satisfied by "),a("code",[t._v("malloc()")]),t._v(" or "),a("code",[t._v("calloc()")]),t._v(". "),a("code",[t._v("malloc()")]),t._v(" and "),a("code",[t._v("calloc()")]),t._v(" functions allocate memory that's suitably aligned for "),a("strong",[t._v("any")]),t._v(" object type (i.e. the alignment is "),a("code",[t._v("alignof(max_align_t)")]),t._v("). But with "),a("code",[t._v("aligned_alloc()")]),t._v(" greater alignments can be requested.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Allocates 1024 bytes with 256 bytes alignment. */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("aligned_alloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aligned_alloc()"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("The C11 standard imposes two restrictions: 1) the "),a("strong",[t._v("size")]),t._v(" (second argument) requested must be an integral multiple of the "),a("strong",[t._v("alignment")]),t._v(" (first argument) and 2) the value of "),a("strong",[t._v("alignment")]),t._v(" should be a valid alignment supported by the implementation. Failure to meet either of them results in "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/364/undefined-behavior",target:"_blank",rel:"noopener noreferrer"}},[t._v("undefined behavior"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"reallocating-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reallocating-memory"}},[t._v("#")]),t._v(" Reallocating Memory")]),t._v(" "),a("p",[t._v("You may need to expand or shrink your pointer storage space after you have allocated memory to it.  The "),a("code",[t._v("void *realloc(void *ptr, size_t size)")]),t._v(" function deallocates the old object pointed to by "),a("code",[t._v("ptr")]),t._v(" and returns a pointer to an object that has the size specified by "),a("code",[t._v("size")]),t._v(". "),a("code",[t._v("ptr")]),t._v(" is the pointer to a memory block previously allocated with "),a("code",[t._v("malloc")]),t._v(", "),a("code",[t._v("calloc")]),t._v(" or "),a("code",[t._v("realloc")]),t._v(" (or a null pointer) to be reallocated. The maximal possible contents of the original memory is preserved. If the new size is larger, any additional memory beyond the old size are uninitialized. If the new size is shorter, the contents of the shrunken part is lost. If "),a("code",[t._v("ptr")]),t._v(" is NULL, a new block is allocated and a pointer to it is returned by the function.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"malloc() failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_FAILURE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n    p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Reallocate array to a larger size, storing the result into a\n     * temporary pointer in case realloc() fails. */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("temporary "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("realloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000000")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("temporary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* realloc() failed, the original allocation was not free'd yet. */")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" temporary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"realloc() failed"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Clean up. */")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_FAILURE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("      \n\n        p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" temporary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* From here on, array can be used with the new size it was \n     * realloc'ed to, until it is free'd. */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* The values of p[0] to p[9] are preserved, so this will print:\n       42 15\n    */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d %d\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_SUCCESS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("The reallocated object may or may not have the same address as "),a("code",[t._v("*p")]),t._v(". Therefore it is important to capture the return value from "),a("code",[t._v("realloc")]),t._v(" which contains the new address if the call is successful.")]),t._v(" "),a("p",[t._v("Make sure you assign the return value of "),a("code",[t._v("realloc")]),t._v(" to a "),a("code",[t._v("temporary")]),t._v(" instead of the original "),a("code",[t._v("p")]),t._v(". "),a("code",[t._v("realloc")]),t._v(" will return null in case of any failure, which would overwrite the pointer. This would lose your data and create a memory leak.")]),t._v(" "),a("h2",{attrs:{id:"realloc-ptr-0-is-not-equivalent-to-free-ptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#realloc-ptr-0-is-not-equivalent-to-free-ptr"}},[t._v("#")]),t._v(" realloc(ptr, 0) is not equivalent to free(ptr)")]),t._v(" "),a("p",[a("code",[t._v("realloc")]),t._v(" is "),a("strong",[t._v("conceptually equivalent")]),t._v(" to "),a("code",[t._v("malloc + memcpy + free")]),t._v(" on the other pointer.")]),t._v(" "),a("p",[t._v("If the size of the space requested is zero, the behavior of "),a("code",[t._v("realloc")]),t._v(" is implementation-defined. This is similar for all memory allocation functions that receive a "),a("code",[t._v("size")]),t._v(" parameter of value "),a("code",[t._v("0")]),t._v(". Such functions may in fact return a non-null pointer, but that must never be dereferenced.")]),t._v(" "),a("p",[t._v("Thus, "),a("code",[t._v("realloc(ptr,0)")]),t._v(" is not equivalent to "),a("code",[t._v("free(ptr)")]),t._v(". It may")]),t._v(" "),a("ul",[a("li",[t._v('be a "lazy" implementation and just return '),a("code",[t._v("ptr")])]),t._v(" "),a("li",[a("code",[t._v("free(ptr)")]),t._v(", allocate a dummy element and return that")]),t._v(" "),a("li",[a("code",[t._v("free(ptr)")]),t._v(" and return "),a("code",[t._v("0")])]),t._v(" "),a("li",[t._v("just return "),a("code",[t._v("0")]),t._v(" for failure and do nothing else.")])]),t._v(" "),a("p",[t._v("So in particular the latter two cases are indistinguishable by application code.")]),t._v(" "),a("p",[t._v("This means "),a("code",[t._v("realloc(ptr,0)")]),t._v(" may not really free/deallocate the memory, and thus it should never be used as a replacement for "),a("code",[t._v("free")]),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"multidimensional-arrays-of-variable-size"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multidimensional-arrays-of-variable-size"}},[t._v("#")]),t._v(" Multidimensional arrays of variable size")]),t._v(" "),a("p",[t._v("Since C99, C has variable length arrays, VLA, that model arrays with bounds that are only known at initialization time. While you have to be careful not to allocate too large VLA (they might smash your stack), using "),a("strong",[t._v("pointers to VLA")]),t._v(" and using them in "),a("code",[t._v("sizeof")]),t._v(" expressions is fine.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sumAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" size_t m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size_t j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n          ret "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" A"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ret"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("argv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("argc"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   size_t n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" argc"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   size_t m "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" argc"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("matrix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// initialize matrix somehow")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" res "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sumAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" m"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" matrix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"result is %g\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" res"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("matrix"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Here "),a("code",[t._v("matrix")]),t._v(" is a pointer to elements of type "),a("code",[t._v("double[m]")]),t._v(", and the "),a("code",[t._v("sizeof")]),t._v(" expression with "),a("code",[t._v("double[n][m]")]),t._v(" ensures that it contains space for "),a("code",[t._v("n")]),t._v(" such elements.")]),t._v(" "),a("p",[t._v("All this space is allocated contiguously and can thus be deallocated by a single call to "),a("code",[t._v("free")]),t._v(".")]),t._v(" "),a("p",[t._v("The presence of VLA in the language also affects the possible declarations of arrays and pointers in function headers. Now, a general integer expression is permitted inside the "),a("code",[t._v("[]")]),t._v(" of array parameters. For both functions the expressions in "),a("code",[t._v("[]")]),t._v(" use parameters that have declared before in the parameter list. For "),a("code",[t._v("sumAll")]),t._v(" these are the lengths that the user code expects for the matrix. As for all array function parameters in C the innermost dimension is rewritten to a pointer type, so this is equivalent to the declaration")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n double sumAll(size_t n, size_t m, double (*A)[m]);\n\n")])])]),a("p",[t._v("That is, "),a("code",[t._v("n")]),t._v(" is not really part of the function interface, but the information can be useful for documentation and it could also be used by bounds checking compilers to warn about out-of-bounds access.")]),t._v(" "),a("p",[t._v("Likwise, for "),a("code",[t._v("main")]),t._v(", the expression "),a("code",[t._v("argc+1")]),t._v(" is the minimal length that the C standard prescribes for the "),a("code",[t._v("argv")]),t._v(" argument.")]),t._v(" "),a("p",[t._v("Note that officially VLA support is optional in C11, but we know of no compiler that implements C11 and that doesn't have them. You could test with the macro "),a("code",[t._v("__STDC_NO_VLA__")]),t._v(" if you must.")]),t._v(" "),a("h2",{attrs:{id:"alloca-allocate-memory-on-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alloca-allocate-memory-on-stack"}},[t._v("#")]),t._v(" alloca: allocate memory on stack")]),t._v(" "),a("p",[a("strong",[t._v("Caveat:")]),t._v(" "),a("code",[t._v("alloca")]),t._v(" is only mentioned here for the sake of completeness. It is entirely non-portable (not covered by any of the common standards) and has a number of potentially dangerous features that make it un-safe for the unaware. Modern C code should replace it with "),a("strong",[t._v("Variable Length Arrays")]),t._v(" (VLA).")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://linux.die.net/man/3/alloca",target:"_blank",rel:"noopener noreferrer"}},[t._v("Manual page"),a("OutboundLink")],1)]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<alloca.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// glibc version of stdlib.h include alloca.h by default")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("data "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("alloca")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n      function body;\n    */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// data is automatically freed")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Allocate memory on the stack frame of the caller, the space referenced by the returned pointer is automatically "),a("a",{attrs:{href:"https://linux.die.net/man/3/free",target:"_blank",rel:"noopener noreferrer"}},[t._v("free"),a("OutboundLink")],1),t._v("'d when the caller function finishes.")]),t._v(" "),a("p",[t._v("While this function is convenient for automatic memory management, be aware that requesting large allocation could cause a stack overflow, and that you cannot use "),a("a",{attrs:{href:"https://linux.die.net/man/3/free",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("free")]),a("OutboundLink")],1),t._v(" with memory allocated with "),a("a",{attrs:{href:"https://linux.die.net/man/3/alloca",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("alloca")]),a("OutboundLink")],1),t._v(" (which could cause more issue with stack overflow).")]),t._v(" "),a("p",[t._v("For these reason it is not recommended to use "),a("a",{attrs:{href:"https://linux.die.net/man/3/alloca",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("alloca")]),a("OutboundLink")],1),t._v(" inside a loop nor a recursive function.")]),t._v(" "),a("p",[t._v("And because the memory is "),a("a",{attrs:{href:"https://linux.die.net/man/3/free",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("free")]),a("OutboundLink")],1),t._v("'d upon function return you cannot return the pointer as a function result ("),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/364/undefined-behavior",target:"_blank",rel:"noopener noreferrer"}},[t._v("the behavior would be undefined"),a("OutboundLink")],1),t._v(").")]),t._v(" "),a("h3",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[t._v("#")]),t._v(" Summary")]),t._v(" "),a("ul",[a("li",[t._v("call identical to "),a("a",{attrs:{href:"https://linux.die.net/man/3/malloc",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("malloc")]),a("OutboundLink")],1)]),t._v(" "),a("li",[t._v("automatically free'd upon function return")]),t._v(" "),a("li",[t._v("incompatible with "),a("a",{attrs:{href:"https://linux.die.net/man/3/free",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("free")]),a("OutboundLink")],1),t._v(","),a("a",{attrs:{href:"https://linux.die.net/man/3/realloc",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("realloc")]),a("OutboundLink")],1),t._v(" functions ("),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/364/undefined-behavior",target:"_blank",rel:"noopener noreferrer"}},[t._v("undefined behavior"),a("OutboundLink")],1),t._v(")")]),t._v(" "),a("li",[t._v("pointer cannot be returned as a function result ("),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/364/undefined-behavior",target:"_blank",rel:"noopener noreferrer"}},[t._v("undefined behavior"),a("OutboundLink")],1),t._v(")")]),t._v(" "),a("li",[t._v("allocation size limited by stack space, which (on most machines) is a lot smaller than the heap space available for use by "),a("code",[t._v("malloc()")])]),t._v(" "),a("li",[t._v("avoid using "),a("code",[t._v("alloca()")]),t._v(" and VLAs (variable length arrays) in a single function")]),t._v(" "),a("li",[a("code",[t._v("alloca()")]),t._v(" is not as portable as "),a("code",[t._v("malloc()")]),t._v(" et al")])]),t._v(" "),a("h3",{attrs:{id:"recommendation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recommendation"}},[t._v("#")]),t._v(" Recommendation")]),t._v(" "),a("ul",[a("li",[t._v("Do not use "),a("code",[t._v("alloca()")]),t._v(" in new code")])]),t._v(" "),a("p",[t._v("Modern alternative.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n      function body;\n    */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// data is automatically freed")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("This works where "),a("code",[t._v("alloca()")]),t._v(" does, and works in places where "),a("code",[t._v("alloca()")]),t._v(" doesn't (inside loops, for example).  It does assume either a C99 implementation or a C11 implementation that does not define "),a("code",[t._v("__STDC_NO_VLA__")]),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"user-defined-memory-management"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user-defined-memory-management"}},[t._v("#")]),t._v(" User-defined memory management")]),t._v(" "),a("p",[a("code",[t._v("malloc()")]),t._v(" often calls underlying operating system functions to obtain pages of memory. But there is nothing special about the function and it can be implemented in straight C by declaring a large static array and allocating from it (there is a slight difficulty in ensuring correct alignment, in practice aligning to 8 bytes is almost always adequate).")]),t._v(" "),a("p",[t._v("To implement a simple scheme, a control block is stored in the region of memory immediately before the pointer to be returned from the call. This means that "),a("code",[t._v("free()")]),t._v(" may be implemented by subtracting from the returned pointer and reading off the control information, which is typically the block size plus some information that allows it to be put back in the free list - a linked list of unallocated blocks.")]),t._v(" "),a("p",[t._v("When the user requests an allocation, the free list is searched until a block of identical or larger size to the amount requested is found, then if necessary it is split. This can lead to memory fragmentation if the user is continually making many allocations and frees of unpredictable size and and at unpredictable intervals (not all real programs behave like that, the simple scheme is often adequate for small programs).")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* typical control block */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("block")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   size_t size"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* size of block */")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("block")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* next block in free list */")]),t._v(" \n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("block")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("prev"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* back pointer to previous block in memory */")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("padding"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* need 16 bytes to make multiple of 8 */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("block")]),t._v(" arena"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* allocate from here */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("block")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("firstfree"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Many programs require large numbers of allocations of small objects of the same size. This is very easy to implement. Simply use a block with a next pointer. So if a block of 32 bytes is required:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" block\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" payload"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  \n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" block arena"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        arena"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("arena"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    arena"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* last one, null */")]),t._v("\n    head "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("block_alloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("answer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("answer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        head "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" answer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("block_free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("union")]),t._v(" block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    block"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" head"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    head "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("This scheme is extremely fast and efficient, and can be made generic with a certain loss of clarity.")]),t._v(" "),a("h4",{attrs:{id:"syntax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),a("ul",[a("li",[t._v("void "),a("em",[t._v("aligned_alloc(size_t alignment, size_t size); /")]),t._v(" Only since C11 */")]),t._v(" "),a("li",[t._v("void *calloc(size_t nelements, size_t size);")]),t._v(" "),a("li",[t._v("void free(void *ptr);")]),t._v(" "),a("li",[t._v("void *malloc(size_t size);")]),t._v(" "),a("li",[t._v("void *realloc(void *ptr, size_t size);")]),t._v(" "),a("li",[t._v("void "),a("em",[t._v("alloca(size_t size); /")]),t._v(" from alloca.h, not standard, not portable, dangerous. */")])]),t._v(" "),a("h4",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("name")]),t._v(" "),a("th",[t._v("description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("size ("),a("code",[t._v("malloc")]),t._v(", "),a("code",[t._v("realloc")]),t._v(" and "),a("code",[t._v("aligned_alloc")]),t._v(")")]),t._v(" "),a("td",[t._v("total size of the memory in bytes. For "),a("code",[t._v("aligned_alloc")]),t._v(" the size must be a integral multiple of alignment.")])]),t._v(" "),a("tr",[a("td",[t._v("size ("),a("code",[t._v("calloc")]),t._v(")")]),t._v(" "),a("td",[t._v("size of each element")])]),t._v(" "),a("tr",[a("td",[t._v("nelements")]),t._v(" "),a("td",[t._v("number of elements")])]),t._v(" "),a("tr",[a("td",[t._v("ptr")]),t._v(" "),a("td",[t._v("pointer to allocated memory previously returned by "),a("code",[t._v("malloc")]),t._v(", "),a("code",[t._v("calloc")]),t._v(", "),a("code",[t._v("realloc")]),t._v(" or "),a("code",[t._v("aligned_alloc")])])]),t._v(" "),a("tr",[a("td",[t._v("alignment")]),t._v(" "),a("td",[t._v("alignment of allocated memory")])])])]),t._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),a("p",[t._v("Note that "),a("code",[t._v("aligned_alloc()")]),t._v(" is only defined for C11 or later.")]),t._v(" "),a("p",[t._v("Systems such as those based on "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/posix",target:"_blank",rel:"noopener noreferrer"}},[t._v("POSIX"),a("OutboundLink")],1),t._v(" provide other ways of allocating aligned memory (e.g. "),a("a",{attrs:{href:"http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("posix_memalign()")]),a("OutboundLink")],1),t._v("), and also have other memory management options (e.g. "),a("a",{attrs:{href:"http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("mmap()")]),a("OutboundLink")],1),t._v(").")])])}),[],!1,null,null,null);e.default=n.exports}}]);